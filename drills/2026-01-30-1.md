# Ruby/Rails デイリードリル - 2026-01-30（セッション1）

## 本日のドリル

### 問題1
以下のRubyコードの出力として正しいものはどれですか？

```ruby
numbers = [1, 2, 3, 4, 5]
result = numbers.select { |n| n.even? }.map { |n| n * 2 }
p result
```

**選択肢：**
- a) `[2, 4, 6, 8, 10]`
- b) `[4, 8]`
- c) `[2, 4]`
- d) `[1, 3, 5]`

**正解：** b

**解説：**
このコードは、メソッドチェーン（複数のメソッドを連続して呼び出す）を使って配列を処理しています。

処理の流れを順に追うと：

1. `numbers.select { |n| n.even? }`
   - 配列 `[1, 2, 3, 4, 5]` から偶数だけを選択
   - 結果は `[2, 4]`（偶数の要素だけが残る）

2. `.map { |n| n * 2 }`
   - 前のステップの結果 `[2, 4]` の各要素を2倍
   - 最終結果は `[4, 8]`

メソッドチェーンは、データ変換の各ステップを明確かつ簡潔に表現できるため、Ruby（特に関数型プログラミングの影響を受けた部分）では非常によく使われる手法です。

**公式リファレンス:**
- [Array#select - Ruby 3.2 リファレンス](https://docs.ruby-lang.org/ja/latest/method/Array/i/select.html)
- [Array#map - Ruby 3.2 リファレンス](https://docs.ruby-lang.org/ja/latest/method/Array/i/map.html)

---

### 問題2
Railsのバリデーションで、メールアドレスが特定のドメイン（例: example.com）のみ許可するバリデーションとして正しいものはどれですか？

```ruby
class User < ApplicationRecord
  # ここにバリデーションを追加
end
```

**選択肢：**
- a) `validates :email, format: { with: /@example\.com\z/, message: "must be from example.com domain" }`
- b) `validates :email, inclusion: { in: "example.com", message: "must be from example.com domain" }`
- c) `validates :email, domain: "example.com", message: "must be from example.com domain" }`
- d) `validates_with ExampleDomainValidator, fields: [:email]`

**正解：** a

**解説：**
Railsには `domain` というバリデーションヘルパーは標準では存在しません。特定のドメインを持つメールアドレスだけを許可するには、一般的に `format` バリデーションと正規表現を組み合わせて使います。

```ruby
validates :email, format: { with: /@example\.com\z/, message: "must be from example.com domain" }
```

この正規表現の意味：
- `@` - 文字「@」にマッチします
- `example\.com` - 「example.com」という文字列にマッチします（`.`はエスケープする必要があります）
- `\z` - 文字列の末尾にマッチします

したがって、この正規表現は「何かしらの文字 + @example.com」で終わるメールアドレスだけを許可します。

他の選択肢の問題点：
- b) `inclusion` バリデーションは値が指定された配列に含まれるかをチェックするもので、ここでの用途には適していません
- c) このようなバリデーションヘルパーは標準では存在しません
- d) カスタムバリデータクラスを示していますが、そのクラスが未定義なので機能しません

**公式リファレンス:**
- [Active Record バリデーション - formatヘルパー | Rails ガイド](https://railsguides.jp/active_record_validations.html#format)

---

### 問題3
Rubyにおけるシンボル（`:symbol`）と文字列（`"string"`）の違いについて、正しい説明はどれですか？

**選択肢：**
- a) シンボルは文字列のエイリアスであり、内部的には同じオブジェクト
- b) シンボルは変更不可能だが、文字列は変更可能
- c) シンボルはオブジェクトIDが毎回再生成されるが、文字列は一度作成したら同じオブジェクトIDを保持する
- d) シンボルは英数字のみ使用可能だが、文字列は任意の文字を含められる

**正解：** b

**解説：**
Rubyにおけるシンボルと文字列の最も重要な違いの一つは、可変性（mutability）です：

- **シンボル**（`:symbol`）は**変更不可能**（immutable）です
- **文字列**（`"string"`）は**変更可能**（mutable）です

例えば、文字列は内容を変更できますが、シンボルは一度作成すると変更できません：

```ruby
# 文字列は変更可能
str = "hello"
str << " world"
puts str  # => "hello world"

# シンボルは変更不可能
sym = :hello
# sym << " world"  # これは実行するとエラーになる
```

他にも重要な違いがあります：

1. **メモリ効率**：同じシンボルは常に同一のオブジェクトを参照しますが、同じ内容の文字列でも別のオブジェクトになることがあります
   ```ruby
   :symbol.object_id == :symbol.object_id  # => true
   "string".object_id == "string".object_id  # => false
   ```

2. **用途**：シンボルはハッシュのキーやメソッド名など、識別子として使われることが多い一方、文字列はテキストデータを表現するのに使います

3. **パフォーマンス**：シンボルの比較は文字列の比較より高速です（シンボルはオブジェクトIDを比較するだけ）

**公式リファレンス:**
- [シンボル - Ruby 3.2 リファレンス](https://docs.ruby-lang.org/ja/latest/class/Symbol.html)
- [文字列 - Ruby 3.2 リファレンス](https://docs.ruby-lang.org/ja/latest/class/String.html)

---

## 結果

**正解数：** 2/3

**今日のポイント：**
1. Rubyのメソッドチェーン（`select`, `map`など）を使った配列の変換処理
2. Railsのバリデーション、特に`format`バリデーションと正規表現の組み合わせ
3. Rubyのシンボルと文字列の違い、特にその可変性の違い