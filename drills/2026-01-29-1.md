# Ruby/Rails デイリードリル - 2026-01-29 (セッション1)

## 本日のドリル

### 問題1

以下のRubyコードの出力は何になりますか？

```ruby
hash = { "a" => 100, "b" => 200 }
hash.each_with_object({}) do |(k, v), result|
  result[k.to_sym] = v * 2
end
p hash
```

**選択肢：**

- a) `{ :a => 200, :b => 400 }`
- b) `{ "a" => 100, "b" => 200 }`
- c) `{}`
- d) `{ "a" => 200, "b" => 400 }`

**正解：** b

**解説：**
この問題のポイントは `each_with_object` メソッドの戻り値と元のオブジェクトの関係です。

`each_with_object` メソッドは、引数として渡したオブジェクトに対して処理をして、**そのオブジェクトを返す**メソッドです。しかし元のハッシュ自体は変更されません。

このコードでは:

1. `hash.each_with_object({})` で空のハッシュを初期値として各要素を処理
2. 各要素のキーをシンボルに変換し、値を2倍にして新しいハッシュ(`result`)に格納
3. **戻り値の新しいハッシュは捨てられている**（変数に代入されていない）
4. 最後に元の `hash` を出力している

結果として、元のハッシュである `{ "a" => 100, "b" => 200 }` が出力されます。

もし新しく作成したハッシュを使いたい場合は:

```ruby
new_hash = hash.each_with_object({}) do |(k, v), result|
  result[k.to_sym] = v * 2
end
p new_hash  # => { :a => 200, :b => 400 }
```

とする必要があります。

**公式リファレンス:**

- [each_with_object (Ruby 3.2 リファレンス)](https://docs.ruby-lang.org/ja/latest/method/Enumerable/i/each_with_object.html)

---

### 問題2

Railsのバリデーションに関する記述で正しいものはどれですか？

**選択肢：**

- a) `validates :name, presence: true` は name 属性が nil または空文字列のときにバリデーションエラーになる
- b) バリデーションは ActiveRecord モデルでのみ使用でき、FormObjectやPORO（Plain Old Ruby Object）では使用できない
- c) `save!` メソッドはバリデーションエラーがあってもデータを保存する
- d) 独自のバリデーションを定義するには、必ず `validate` マクロと `validates_each` マクロを組み合わせる必要がある

**正解：** a

**解説：**
`validates :name, presence: true` は、name 属性が nil または空文字列（`""`）の場合にバリデーションエラーになります。

他の選択肢の誤りを見てみましょう：

- b) 間違いです。バリデーションは `ActiveModel::Validations` をincludeすることで、FormObjectやPORO（Plain Old Ruby Object）でも使用できます。

```ruby
class ContactForm
  include ActiveModel::Validations

  attr_accessor :name, :email

  validates :name, presence: true
  validates :email, format: { with: URI::MailTo::EMAIL_REGEXP }
end
```

- c) 間違いです。`save!` メソッドは逆に、バリデーションエラーがあると例外（`ActiveRecord::RecordInvalid`）を発生させます。通常の `save` はバリデーションエラーの場合に false を返すだけですが、`save!` は例外を投げます。

- d) 間違いです。独自のバリデーションを定義する方法は複数あり、最も一般的な方法は単に `validate` メソッドを使ってインスタンスメソッドを指定するだけです：

```ruby
class User < ApplicationRecord
  validate :password_complexity

  private

  def password_complexity
    # 検証ロジック
    errors.add(:password, "複雑さが不足しています") if password_too_simple?
  end
end
```

**公式リファレンス:**

- [Active Record バリデーション - Rails ガイド](https://railsguides.jp/active_record_validations.html)

---

### 問題3

次のRubyコードの実行結果は何になりますか？

```ruby
def greet(name = "Guest", message: "Hello")
  puts "#{message}, #{name}!"
end

greet("Ruby", message: "Hi")
```

**選択肢：**

- a) `Hi, Ruby!`
- b) `Hello, Ruby!`
- c) `Hi, Guest!`
- d) エラーが発生する

**正解：** a

**解説：**
このコード例では、Rubyのメソッド定義における**位置引数**と**キーワード引数**の組み合わせを扱っています。

```ruby
def greet(name = "Guest", message: "Hello")
```

この定義では：

1. `name` はデフォルト値 "Guest" の**位置引数**
2. `message` はデフォルト値 "Hello" の**キーワード引数**

メソッド呼び出し時：

```ruby
greet("Ruby", message: "Hi")
```

1. 位置引数として "Ruby" が `name` に渡される
2. キーワード引数として "Hi" が `message` に渡される

その結果、`name` には "Ruby"、`message` には "Hi" が格納され、`"#{message}, #{name}!"` の評価結果 `"Hi, Ruby!"` が出力されます。

このコードはエラーにはなりません。キーワード引数と位置引数を混在させることは、Ruby 2.0以降で完全にサポートされています。

**公式リファレンス:**

- [メソッド呼び出し - Ruby 3.2 リファレンス](https://docs.ruby-lang.org/ja/latest/doc/spec=2fcall.html)
- [Rubyのキーワード引数 - Ruby 3.2 リファレンス](https://docs.ruby-lang.org/ja/latest/doc/spec=2fdef.html#keyword)

---

## 結果

**正解数：** 1/3

**今日のポイント：**

1. `each_with_object` メソッドは元のオブジェクトを変更せず、戻り値を変数に代入する必要がある
2. Railsの `presence: true` バリデーションは nil と空文字列をチェックする
3. Rubyでは位置引数とキーワード引数を組み合わせて使用できる
