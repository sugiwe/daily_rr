# Ruby/Rails デイリードリル - 2026-01-29（セッション3）

## 本日のドリル

### 問題1
以下のRubyコードの出力として正しいものはどれですか？

```ruby
def perform(array = [])
  array << "Ruby"
  array
end

result1 = perform
result2 = perform

p result1.object_id == result2.object_id
```

**選択肢：**
- a) `true`
- b) `false`
- c) `nil`
- d) エラーが発生する

**正解：** a

**解説：**
この問題は、Rubyにおける**デフォルト引数の評価タイミング**に関する重要な特性を示しています。

Rubyでは、メソッド定義のデフォルト引数は **メソッド定義時に1回だけ** 評価されます。つまり、`array = []`というデフォルト値は、メソッドが定義された時点で一度だけ空配列が作られ、その後引数なしで`perform`メソッドが呼び出されるたびに、**同じ配列オブジェクト**が再利用されるのです。

処理の流れを追うと：
1. 最初の`result1 = perform`で、デフォルト引数の空配列に`"Ruby"`が追加され`["Ruby"]`となる
2. 次の`result2 = perform`でも同じ配列が使われるため、さらに`"Ruby"`が追加され`["Ruby", "Ruby"]`となる
3. `result1`と`result2`は実際には同じオブジェクト（同じ配列）を参照しているので、`object_id`も同じ

そのため、`result1.object_id == result2.object_id`は`true`になります。また、この時点で`result1`の中身も`["Ruby", "Ruby"]`になっています。

### 回避策
この問題を回避するには、メソッド内でデフォルト値を作成します：

```ruby
def perform(array = nil)
  array = [] if array.nil?
  array << "Ruby"
  array
end
```

または、引数のデフォルト値として`Array.new`を使う方法もありますが、根本的な問題は解決しません。

**公式リファレンス:**
- [メソッド定義 - Ruby 3.2 リファレンス](https://docs.ruby-lang.org/ja/latest/doc/spec=2fdef.html)

---

### 問題2
Railsのルーティングについて、以下のルーティング定義の説明として正しいものはどれですか？

```ruby
Rails.application.routes.draw do
  resources :articles, only: [:index, :show] do
    collection do
      get :search
    end
    
    member do
      post :publish
    end
  end
end
```

**選択肢：**
- a) `/articles/:id/search` と `/articles/:id/publish` の両方のルートが定義される
- b) `/articles/search` と `/articles/:id/publish` のルートが定義される
- c) `/articles/search` と `/publish/articles/:id` のルートが定義される
- d) `/search/articles` と `/articles/:id/publish` のルートが定義される

**正解：** b

**解説：**
Railsのルーティングで重要な2つの概念があります：

**1. collection**
- **コレクション**全体に対する操作を定義します
- **IDを必要としません**
- 例：記事の一覧や検索など
- URLパターン: `/リソース名/アクション名`

**2. member**
- **個別のリソース**に対する操作を定義します
- **IDを必要とします**
- 例：特定の記事の編集や公開など
- URLパターン: `/リソース名/:id/アクション名`

この問題のルーティング定義では：

```ruby
resources :articles, only: [:index, :show] do
  collection do
    get :search   # コレクション（複数の記事）に対する検索
  end
  
  member do
    post :publish  # 個別の記事に対する公開操作
  end
end
```

これにより生成されるルートは：

1. `get '/articles/search'` - IDが不要な記事検索機能（collection）
2. `post '/articles/:id/publish'` - 特定IDの記事を公開する機能（member）

このような定義が便利な理由は、RESTfulな設計に基づいてルーティングが明確になるためです。

**公式リファレンス:**
- [Rails のルーティング - コレクションルート | Rails ガイド](https://railsguides.jp/routing.html#%E3%82%B3%E3%83%AC%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%AB%E3%83%BC%E3%83%88%E3%81%A8%E3%83%A1%E3%83%B3%E3%83%90%E3%83%BC%E3%83%AB%E3%83%BC%E3%83%88%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B)

---

### 問題3
Rubyの`yield`キーワードについて、以下のコードの出力として正しいものはどれですか？

```ruby
def greet
  puts "Hello"
  yield if block_given?
  puts "Goodbye"
end

greet do
  puts "World"
end
```

**選択肢：**
- a) `Hello`
- b) `Hello Goodbye`
- c) `Hello World Goodbye`
- d) `Hello World`

**正解：** c

**解説：**
Rubyの`yield`キーワードは、メソッド内からブロックを呼び出す（実行する）ためのものです。

このコードの実行フローは：

1. `greet` メソッドが呼び出され、実行が始まる
2. まず `puts "Hello"` が実行されて「Hello」と出力
3. `yield if block_given?` の部分で：
   - `block_given?` はブロックが渡されたかを確認するメソッド（この場合は true）
   - `yield` で渡されたブロック（`puts "World"`）が実行される
   - 結果として「World」と出力
4. 最後に `puts "Goodbye"` が実行されて「Goodbye」と出力

そのため、最終的な出力は「Hello」「World」「Goodbye」の3行になります。

`yield`を使うことで、メソッドの振る舞いの一部をメソッドの呼び出し側で柔軟に定義できるようになります。これはRubyの強力な機能の一つで、コードの再利用性と柔軟性を高めるのに役立ちます。

**実用例：**
```ruby
def with_logging
  puts "処理を開始します"
  result = yield  # ブロックを実行して結果を取得
  puts "処理を終了します"
  result  # ブロックの戻り値を返す
end

value = with_logging { 2 * 3 }  # => 処理を開始します、処理を終了します
puts value  # => 6
```

**公式リファレンス:**
- [制御構造 - yield (Ruby 3.2 リファレンス)](https://docs.ruby-lang.org/ja/latest/doc/spec=2fcontrol.html#yield)

---

## 結果

**正解数：** 1/3

**今日のポイント：**
1. Rubyのデフォルト引数は定義時に評価され、その後のメソッド呼び出しで同じオブジェクトが再利用される（特に配列やハッシュなどの変更可能なオブジェクトで注意）
2. Railsのルーティングにおける `collection` と `member` の違い（collection は ID 不要、member は ID 必要）
3. Rubyの `yield` キーワードを使ってメソッド内でブロックを実行する方法